# cs-300-DSA

The main problem addressed in this course was designing a program that could efficiently store, organize, and retrieve course information for an academic advising system. The program needed to load course data from a file, display all courses in alphanumeric order, and allow users to search for a specific course and view its prerequisites. To solve this problem, different data structures were analyzed and compared to determine which one best met the functional and performance requirements of the system.

I approached the problem by first analyzing the requirements and then evaluating multiple data structures, including vectors, hash tables, and binary search trees. Understanding data structures was critical because each option affects runtime efficiency, memory usage, and how easily data can be organized and retrieved. In Project One, I focused on analyzing the runtime behavior of each structure. In Project Two, I applied that analysis by implementing a binary search tree, which naturally supports ordered output and efficient searching, making it a good fit for the advising system.

One of the main challenges was ensuring that the data loaded correctly from the CSV file and that prerequisites were handled consistently. I overcame this by breaking the problem into smaller steps, validating file input, and testing each feature independently before combining them. Another challenge was implementing the binary search tree correctly, especially insertion and traversal logic. Careful debugging, reviewing algorithm behavior, and testing edge cases helped resolve these issues.

This project expanded my approach by reinforcing the importance of planning before coding. Instead of immediately writing code, I learned to analyze the problem, compare possible solutions, and select a design that best aligns with performance and usability goals. I now consider efficiency, scalability, and data organization earlier in the development process, rather than treating them as afterthoughts.

Through this course, I became more intentional about writing clean, modular code. I used clear data structures, meaningful variable and function names, and separated responsibilities across functions and classes. This makes the program easier to read, maintain, and extend in the future. The use of structured logic and well-defined data models also makes it easier to adapt the program if requirements change, such as adding new features or supporting larger datasets.
